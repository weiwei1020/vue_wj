{"version":3,"sources":["webpack:///webpack/bootstrap","webpack:///./sources/core/links_common.js","webpack:///./sources/ext/critical_path.js"],"names":["installedModules","__webpack_require__","moduleId","exports","module","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","prototype","hasOwnProperty","p","s","gantt","_get_linked_task","link","getTarget","task","taskId","target","source","isTaskExists","getTask","_get_link_target","_get_link_source","caching","formattedLinksStash","inheritedSuccessorsStash","inheritedPredecessorsStash","getPredecessorsCache","_isLinksCacheEnabled","_startLinksCache","_endLinksCache","_formatLink","id","relations","this","isSummaryTask","isChildOf","from","_getImplicitLinks","respectTargetOffset","config","auto_scheduling_move_projects","targetDates","getSubtaskDates","start_date","end_date","to","$target","length","getState","drag_id","calculateDuration","fromLength","fromTask","j","toLength","toTask","lag","subtaskLink","type","push","_convertToFinishToStartLink","taskParent","_isAutoSchedulable","auto_scheduling","parent","selectOffset","selectSourceLinks","skipChild","children","eachTask","linksCollection","$source","siblingLink","getLink","siblingId","siblingTask","Math","abs","duration","_getDirectDependencies","selectSuccessors","links","successors","linksIds","concat","_getInheritedDependencies","cacheCollection","stop","inheritedRelations","getParent","eachParent","parentDependencies","apply","_getDirectSuccessors","_getInheritedSuccessors","_getDirectPredecessors","_getInheritedPredecessors","_getSuccessors","skipInherited","_getPredecessors","result","predecessors","sourceTask","targetTask","sourceParent","targetParent","res","finish_to_start","preferredStart","additionalLag","start_to_start","finish_to_finish","start_to_finish","highlight_critical_path","_criticalPathHandler","render","attachEvent","_isCriticalTask","chain","path","_isProjectEnd","clearCache","_getDependencies","next","_getSlack","isCriticalTask","assert","undefined","isCriticalLink","getSlack","task1","task2","common","slacks","min","next_task","relation","types","getTaskType","milestone","_getProjectEnd","tasks","getTaskByTime","sort","a","b","_hasDuration","_getSummaryPredecessors"],"mappings":"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","file":"ext/dhtmlxgantt_critical_path.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"/codebase/\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 208);\n","module.exports = function(gantt) {\n// helpers for building chain of dependencies, used for critical path calculation and for auto scheduling\n\n\tgantt._get_linked_task = function (link, getTarget) {\n\t\tvar task = null;\n\t\tvar taskId = getTarget ? link.target : link.source;\n\n\t\tif (gantt.isTaskExists(taskId)) {\n\t\t\ttask = gantt.getTask(taskId);\n\t\t}\n\n\t\treturn task;\n\t};\n\tgantt._get_link_target = function (link) {\n\t\treturn gantt._get_linked_task(link, true);\n\t};\n\n\tgantt._get_link_source = function (link) {\n\t\treturn gantt._get_linked_task(link, false);\n\t};\n\n\tvar caching = false;\n\tvar formattedLinksStash = {};\n\tvar inheritedSuccessorsStash = {};\n\tvar inheritedPredecessorsStash = {};\n\tvar getPredecessorsCache = {};\n\n\n\tgantt._isLinksCacheEnabled = function(){\n\t\treturn caching;\n\t};\n\tgantt._startLinksCache = function(){\n\t\tformattedLinksStash = {};\n\t\tinheritedSuccessorsStash = {};\n\t\tinheritedPredecessorsStash = {};\n\t\tgetPredecessorsCache = {};\n\t\tcaching = true;\n\t};\n\tgantt._endLinksCache = function(){\n\t\tformattedLinksStash = {};\n\t\tinheritedSuccessorsStash = {};\n\t\tinheritedPredecessorsStash = {};\n\t\tgetPredecessorsCache = {};\n\t\tcaching = false;\n\t};\n\n\tgantt._formatLink = function (link) {\n\n\n\t\tif(caching && formattedLinksStash[link.id]){\n\t\t\treturn formattedLinksStash[link.id];\n\t\t}\n\n\t\tvar relations = [];\n\t\tvar target = this._get_link_target(link);\n\t\tvar source = this._get_link_source(link);\n\n\t\tif (!(source && target)) {\n\t\t\treturn relations;\n\t\t}\n\n\t\tif ((gantt.isSummaryTask(target) && gantt.isChildOf(source.id, target.id)) || (gantt.isSummaryTask(source) && gantt.isChildOf(target.id, source.id))) {\n\t\t\treturn relations;\n\t\t}\n\n\n\t\t// there are three kinds of connections at this point\n\t\t// task -> task - regular link\n\t\t// task -> project - transform it into set of regular links (task -> [each subtask]), use offset beetween subtask and project dates as lag, in order not to change mutual positions of subtasks inside a project\n\t\t// project -> task - transform it into ([each subtask] -> task) links\n\t\t// project -> project - transform it into ([each subtask of p1] -> [each subtask of p2]) links\n\n\t\tvar from = this._getImplicitLinks(link, source, function (c) {\n\t\t\treturn 0;\n\t\t}, true);\n\n\t\tvar respectTargetOffset = gantt.config.auto_scheduling_move_projects;\n\t\tvar targetDates = this.isSummaryTask(target) ? this.getSubtaskDates(target.id) : {\n\t\t\tstart_date: target.start_date,\n\t\t\tend_date: target.end_date\n\t\t};\n\t\tvar to = this._getImplicitLinks(link, target, function (c) {\n\t\t\tif (!respectTargetOffset) {\n\t\t\t\treturn 0;\n\t\t\t} else {\n\n\t\t\t\tif (!c.$target.length && !(gantt.getState().drag_id == c.id)) {// drag_id - virtual lag shouldn't restrict task that is being moved inside project\n\t\t\t\t\treturn gantt.calculateDuration({\n\t\t\t\t\t\tstart_date: targetDates.start_date,\n\t\t\t\t\t\tend_date: c.start_date,\n\t\t\t\t\t\ttask: source\n\t\t\t\t\t});\n\t\t\t\t} else {\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\n\t\tfor (var i = 0, fromLength = from.length; i < fromLength; i++) {\n\t\t\tvar fromTask = from[i];\n\t\t\tfor (var j = 0, toLength = to.length; j < toLength; j++) {\n\t\t\t\tvar toTask = to[j];\n\n\t\t\t\tvar lag = fromTask.lag * 1 + toTask.lag * 1;\n\n\t\t\t\tvar subtaskLink = {\n\t\t\t\t\tid: link.id,\n\t\t\t\t\ttype: link.type,\n\t\t\t\t\tsource: fromTask.task,\n\t\t\t\t\ttarget: toTask.task,\n\t\t\t\t\tlag: (link.lag * 1 || 0) + lag\n\t\t\t\t};\n\n\t\t\t\trelations.push(gantt._convertToFinishToStartLink(toTask.task, subtaskLink, source, target, fromTask.taskParent, toTask.taskParent));\n\t\t\t}\n\t\t}\n\n\t\tif(caching)\n\t\t\tformattedLinksStash[link.id] = relations;\n\n\t\treturn relations;\n\t};\n\ngantt._isAutoSchedulable = function(task){\n\treturn task.auto_scheduling !== false;\n};\n\ngantt._getImplicitLinks = function(link, parent, selectOffset, selectSourceLinks){\n\tvar relations = [];\n\n\tif(this.isSummaryTask(parent)){\n\n\t\t// if the summary task contains multiple chains of linked tasks - no need to consider every task of the chain,\n\t\t// it will be enough to check the first/last tasks of the chain\n\t\t// special conditions if there are unscheduled tasks in the chain, or negative lag values that put the end date of the successor task prior to its predecessors' date\n\t\tvar children = {};\n\t\tthis.eachTask(function(c){\n\t\t\tif(!this.isSummaryTask(c)){\n\t\t\t\tchildren[c.id] = c;\n\t\t\t}\n\t\t}, parent.id);\n\n\t\tvar skipChild;\n\n\t\tfor(var c in children){\n\t\t\tvar task = children[c];\n\t\t\tvar linksCollection = selectSourceLinks ? task.$source : task.$target;\n\n\t\t\tskipChild = false;\n\n\t\t\tfor(var l = 0; l < linksCollection.length; l++){\n\t\t\t\tvar siblingLink = gantt.getLink(linksCollection[l]);\n\t\t\t\tvar siblingId = selectSourceLinks ? siblingLink.target : siblingLink.source;\n\t\t\t\tvar siblingTask = children[siblingId];\n\t\t\t\tif(siblingTask && task.auto_scheduling !== false && siblingTask.auto_scheduling !== false){\n\t\t\t\t\tif((siblingLink.target == siblingTask.id && Math.abs(siblingLink.lag) <= siblingTask.duration) ||\n\t\t\t\t\t\t(siblingLink.target == task.id && Math.abs(siblingLink.lag) <= task.duration) ){\n\t\t\t\t\t\tskipChild = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(!skipChild){\n\t\t\t\trelations.push({task: task.id, taskParent: task.parent, lag: selectOffset(task)});\n\t\t\t}\n\t\t}\n\n\t}else{\n\t\trelations.push({task:parent.id, taskParent: parent.parent, lag: 0});\n\t}\n\n\t\treturn relations;\n};\n\n\tgantt._getDirectDependencies = function (task, selectSuccessors) {\n\n\t\tvar links = [],\n\t\t\tsuccessors = [];\n\n\t\tvar linksIds = selectSuccessors ? task.$source : task.$target;\n\n\tfor(var i = 0; i < linksIds.length; i++){\n\t\tvar link = this.getLink(linksIds[i]);\n\t\tif(this.isTaskExists(link.source) && this.isTaskExists(link.target)) {\n\t\t\tvar target = this.getTask(link.target);\n\t\t\tif(this._isAutoSchedulable(target)){\n\t\t\t\tlinks.push(this.getLink(linksIds[i]));\n\t\t\t}\n\t\t}\n\t}\n\n\t\tfor (var i = 0; i < links.length; i++) {\n\t\t\tsuccessors = successors.concat(this._formatLink(links[i]));\n\t\t}\n\n\t\treturn successors;\n\t};\n\n\tgantt._getInheritedDependencies = function (task, selectSuccessors) {\n\n\t\t//var successors = [];\n\tvar stop = false;\n\tvar inheritedRelations = [];\n\tvar cacheCollection;\n\tif(this.isTaskExists(task.id)){\n\n\t\tvar parent = this.getParent(task.id);\n\n\n\t\tthis.eachParent(function(parent){\n\t\t\tif(stop)\n\t\t\t\treturn;\n\n\t\t\tif(caching){\n\t\t\t\tcacheCollection = selectSuccessors ? inheritedSuccessorsStash : inheritedPredecessorsStash;\n\t\t\t\tif(cacheCollection[parent.id]){\n\t\t\t\t\tinheritedRelations.push.apply(inheritedRelations, cacheCollection[parent.id]);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tvar parentDependencies;\n\t\t\tif(this.isSummaryTask(parent)){\n\t\t\t\tif(!this._isAutoSchedulable(parent)){\n\t\t\t\t\tstop = true;\n\t\t\t\t}else{\n\t\t\t\t\tparentDependencies = this._getDirectDependencies(parent, selectSuccessors);\n\t\t\t\t\tif(caching){\n\t\t\t\t\t\tcacheCollection[parent.id] = parentDependencies;\n\t\t\t\t\t}\n\t\t\t\t\tinheritedRelations.push.apply(inheritedRelations, parentDependencies);\n\t\t\t\t}\n\t\t\t}\n\n\t\t}, task.id, this);\n\n\t\t//\tfor (var i = 0; i < inheritedRelations.length; i++) {\n\t\t//\t\tsuccessors.push(inheritedRelations[i]);\n\t\t//\t}\n\t\t}\n\n\t\treturn inheritedRelations;\n\t};\n\n\n\tgantt._getDirectSuccessors = function (task) {\n\t\treturn this._getDirectDependencies(task, true);\n\t};\n\n\tgantt._getInheritedSuccessors = function (task) {\n\t\treturn this._getInheritedDependencies(task, true);\n\t};\n\n\tgantt._getDirectPredecessors = function (task) {\n\t\treturn this._getDirectDependencies(task, false);\n\t};\n\n\tgantt._getInheritedPredecessors = function (task) {\n\t\treturn this._getInheritedDependencies(task, false);\n\t};\n\n\tgantt._getSuccessors = function (task, skipInherited) {\n\t\tvar successors = this._getDirectSuccessors(task);\n\t\tif(skipInherited){\n\t\t\treturn successors;\n\t\t}else{\n\t\t\treturn successors.concat(this._getInheritedSuccessors(task));\n\t\t}\n\t};\n\n\tgantt._getPredecessors = function (task, skipInherited) {\n\t\tvar key = task.id + skipInherited;\n\t\tvar result;\n\n\t\tif(caching && getPredecessorsCache[key]){\n\t\t\treturn getPredecessorsCache[key];\n\t\t}\n\n\t\tvar predecessors = this._getDirectPredecessors(task);\n\t\tif(skipInherited){\n\t\t\tresult = predecessors;\n\t\t}else{\n\t\t\tresult = predecessors.concat(this._getInheritedPredecessors(task));\n\t\t}\n\t\tif(caching){\n\t\t\tgetPredecessorsCache[key] = result;\n\t\t}\n\t\treturn result;\n\t};\n\n\n\tgantt._convertToFinishToStartLink = function (id, link, sourceTask, targetTask, sourceParent, targetParent) {\n\t\t// convert finish-to-finish, start-to-finish and start-to-start to finish-to-start link and provide some additional properties\n\t\tvar res = {\n\t\t\ttarget: id,\n\t\t\tlink: gantt.config.links.finish_to_start,\n\t\t\tid: link.id,\n\t\t\tlag: link.lag || 0,\n\t\t\tsource: link.source,\n\t\t\tpreferredStart: null,\n\t\t\tsourceParent: sourceParent,\n\t\t\ttargetParent: targetParent\n\t\t};\n\n\t\tvar additionalLag = 0;\n\t\tswitch (link.type) {\n\t\t\tcase gantt.config.links.start_to_start:\n\t\t\t\tadditionalLag = -sourceTask.duration;\n\t\t\t\tbreak;\n\t\t\tcase gantt.config.links.finish_to_finish:\n\t\t\t\tadditionalLag = -targetTask.duration;\n\t\t\t\tbreak;\n\t\t\tcase gantt.config.links.start_to_finish:\n\t\t\t\tadditionalLag = -sourceTask.duration - targetTask.duration;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tadditionalLag = 0;\n\t\t}\n\n\t\tres.lag += additionalLag;\n\t\treturn res;\n\t};\n};","require(\"../core/links_common\")(gantt);\n\ngantt.config.highlight_critical_path = false;\ngantt._criticalPathHandler = function(){\n\tif(gantt.config.highlight_critical_path)\n\t\tgantt.render();\n};\ngantt.attachEvent(\"onAfterLinkAdd\", gantt._criticalPathHandler);\ngantt.attachEvent(\"onAfterLinkUpdate\", gantt._criticalPathHandler);\ngantt.attachEvent(\"onAfterLinkDelete\", gantt._criticalPathHandler);\ngantt.attachEvent(\"onAfterTaskAdd\", gantt._criticalPathHandler);\ngantt.attachEvent(\"onAfterTaskUpdate\", gantt._criticalPathHandler);\ngantt.attachEvent(\"onAfterTaskDelete\", gantt._criticalPathHandler);\n\n\ngantt._isCriticalTask = function(task, chain){\n\tif(!task || !task.id) return;\n\tvar path = chain || {};\n\n\tif(this._isProjectEnd(task)){\n\t\treturn true;\n\t}else{\n\n\t\tvar clearCache = false;\n\t\tif(!gantt._isLinksCacheEnabled()) {\n\t\t\tgantt._startLinksCache();\n\t\t\tclearCache = true;\n\t\t}\n\n\t\tpath[task.id] = true;\n\t\tvar successors = this._getDependencies(task);\n\t\tfor(var i=0; i < successors.length; i++){\n\t\t\tvar next = this.getTask(successors[i].target);\n\t\t\tif(this._getSlack(task, next, successors[i]) <= 0 && (!path[next.id] && this._isCriticalTask(next, path)))\n\t\t\t\treturn true;\n\t\t}\n\n\t\tif(clearCache)\n\t\t\tgantt._endLinksCache();\n\t}\n\n\treturn false;\n};\n\ngantt.isCriticalTask = function (task) {\n\tgantt.assert(!!(task && task.id !== undefined), \"Invalid argument for gantt.isCriticalTask\");\n\treturn this._isCriticalTask(task, {});\n};\n\ngantt.isCriticalLink = function (link) {\n\treturn this.isCriticalTask(gantt.getTask(link.source));\n};\n\ngantt.getSlack = function(task1, task2){\n\tvar relations = [];\n\tvar common = {};\n\tfor(var i=0; i < task1.$source.length; i++){\n\t\tcommon[task1.$source[i]] = true;\n\t}\n\tfor(var i=0; i < task2.$target.length; i++){\n\t\tif(common[task2.$target[i]])\n\t\t\trelations.push(task2.$target[i]);\n\t}\n\n\tvar slacks = [];\n\tfor(var i=0; i < relations.length; i++){\n\t\tvar link = this.getLink(relations[i]);\n\t\tslacks.push(this._getSlack(task1, task2, this._convertToFinishToStartLink(link.id, link, task1, task2, task1.parent, task2.parent)));\n\t}\n\n\treturn Math.min.apply(Math, slacks);\n};\n\ngantt._getSlack = function (task, next_task, relation) {\n\t// relation - link expressed as finish-to-start (gantt._convertToFinishToStartLink)\n\tvar types = this.config.types;\n\n\tvar from = null;\n\tif(this.getTaskType(task.type) == types.milestone){\n\t\tfrom = task.start_date;\n\t}else{\n\t\tfrom = task.end_date;\n\t}\n\n\tvar to = next_task.start_date;\n\n\tvar duration = 0;\n\tif(+from > +to){\n\t\tduration = -this.calculateDuration({start_date: to, end_date: from, task: task});\n\t}else{\n\t\tduration = this.calculateDuration({start_date: from, end_date: to, task: task});\n\t}\n\n\tvar lag = relation.lag;\n\tif(lag && lag*1 == lag){\n\t\tduration -= lag;\n\t}\n\n\treturn duration;\n};\n\ngantt._getProjectEnd = function () {\n\tvar tasks = gantt.getTaskByTime();\n\ttasks = tasks.sort(function (a, b) { return +a.end_date > +b.end_date ? 1 : -1; });\n\treturn tasks.length ? tasks[tasks.length - 1].end_date : null;\n};\n\ngantt._isProjectEnd = function (task) {\n\treturn !(this._hasDuration({start_date:task.end_date, end_date: this._getProjectEnd(), task:task}));\n};\n\ngantt._getSummaryPredecessors = function(task){\n\tvar predecessors = [];\n\n\t// all constraints that are applied to summary parents must be applied to the task\n\tthis.eachParent(function(parent){\n\t\tif(this.isSummaryTask(parent))\n\t\t\tpredecessors = predecessors.concat(gantt._getDependencies(parent));\n\t}, task);\n\n\treturn predecessors;\n};\n\n\ngantt._getDependencies = function(task){\n\tvar successors = this._getSuccessors(task).concat(\n\t\tthis._getSummaryPredecessors(task)\n\t);\n\treturn successors;\n};\n"],"sourceRoot":""}