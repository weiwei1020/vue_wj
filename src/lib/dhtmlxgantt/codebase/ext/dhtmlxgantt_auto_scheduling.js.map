{"version":3,"sources":["webpack:///webpack/bootstrap","webpack:///./sources/core/links_common.js","webpack:///./sources/ext/auto_scheduling.js","webpack:///./sources/utils/helpers.js"],"names":["installedModules","__webpack_require__","moduleId","exports","module","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","prototype","hasOwnProperty","p","s","gantt","_get_linked_task","link","getTarget","task","taskId","target","source","isTaskExists","getTask","_get_link_target","_get_link_source","caching","formattedLinksStash","inheritedSuccessorsStash","inheritedPredecessorsStash","getPredecessorsCache","_isLinksCacheEnabled","_startLinksCache","_endLinksCache","_formatLink","id","relations","this","isSummaryTask","isChildOf","from","_getImplicitLinks","respectTargetOffset","config","auto_scheduling_move_projects","targetDates","getSubtaskDates","start_date","end_date","to","$target","length","getState","drag_id","calculateDuration","fromLength","fromTask","j","toLength","toTask","lag","subtaskLink","type","push","_convertToFinishToStartLink","taskParent","_isAutoSchedulable","auto_scheduling","parent","selectOffset","selectSourceLinks","skipChild","children","eachTask","linksCollection","$source","siblingLink","getLink","siblingId","siblingTask","Math","abs","duration","_getDirectDependencies","selectSuccessors","links","successors","linksIds","concat","_getInheritedDependencies","cacheCollection","stop","inheritedRelations","getParent","eachParent","parentDependencies","apply","_getDirectSuccessors","_getInheritedSuccessors","_getDirectPredecessors","_getInheritedPredecessors","_getSuccessors","skipInherited","_getPredecessors","result","predecessors","sourceTask","targetTask","sourceParent","targetParent","res","finish_to_start","preferredStart","additionalLag","start_to_start","finish_to_finish","start_to_finish","auto_scheduling_descendant_links","auto_scheduling_initial","auto_scheduling_strict","helpers","breadthFirstSearch","v","visited","currentVertex","queue","groupTasks","groupLinks","shift","splice","linksArray","tasks","_autoSchedulingGraph","getVertices","rel","ids","len","vertices","topologicalSort","edges","hash","$incoming","successor","S","filter","L","pop","node","_groupEdgesBySource","edge","tarjanStronglyConnectedComponents","vertexId","verticesHash","index","connectedEdges","connectedComponents","edgesFromTasks","undefined","getVertex","strongConnect","previousLink","lowLink","onStack","e","w","min","connectedComponent","_autoSchedulingPath","getKey","getVirtualRoot","mixin","root_id","types","project","$virtual","filterDuplicates","keys","getLinkedTasks","includePredecessors","startIds","clearCache","_getLinkedTasks","rootTask","visitedTasks","isChild","rootObj","linkKey","isSameParent","hasChild","getChildren","findLoops","cycles","forEach","graph","component","_autoSchedulingDateResolver","isFirstSmaller","small","big","valueOf","_hasDuration","isSmallerOrDefault","smallDate","bigDate","resolveRelationDate","getEndDate","minStart","linkId","defaultStart","relation","constraintDate","getConstraintDate","getClosestWorkTime","date","dir","predecessorEnd","successorStart","calculateEndDate","_autoSchedulingPlanner","generatePlan","orderedIds","predecessorRelations","plansHash","getPredecessorEndDate","plan","dateResolver","currentId","isLinkExists","predecessor","callEvent","applyProjectPlan","projectPlan","updateTasks","newDate","_autoSchedulingPreferredDates","startTask","Date","_autoSchedule","updateCallback","_autoscheduling_in_progress","updatedTasks","planner","autoSchedule","inclusive","startAutoSchedule","now","_finalizeAutoSchedulingChanges","batchUpdate","payload","updateTask","resetTime","start","end","resetProjectDates","isCircularLink","_getConnectedGroup","manager","allRelations","findCycles","_attachAutoSchedulingHandlers","movedTask","_autoScheduleAfterLinkChange","attachEvent","_preventCircularLink","_preventDescendantLink","_datesNotEqual","dateA","dateB","taskA","taskB","_notEqualTaskDates","task1","task2","milestone","_autoScheduleAfterDND","newTask","skipped","originalLink","presentLinks","updatedLinks","resetToStartLinksLags","_lightBoxChangesHandler","oldTask","_autoschedule_lightbox_id","_lightBoxSaveHandler","getConnectedGroup","root","groups","findGroups","units","second","minute","hour","day","week","month","quarter","year","getSecondsInUnit","unit","arr","callback","workArray","slice","arrayMap","map","resArray"],"mappings":"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","file":"ext/dhtmlxgantt_auto_scheduling.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"/codebase/\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 209);\n","module.exports = function(gantt) {\n// helpers for building chain of dependencies, used for critical path calculation and for auto scheduling\n\n\tgantt._get_linked_task = function (link, getTarget) {\n\t\tvar task = null;\n\t\tvar taskId = getTarget ? link.target : link.source;\n\n\t\tif (gantt.isTaskExists(taskId)) {\n\t\t\ttask = gantt.getTask(taskId);\n\t\t}\n\n\t\treturn task;\n\t};\n\tgantt._get_link_target = function (link) {\n\t\treturn gantt._get_linked_task(link, true);\n\t};\n\n\tgantt._get_link_source = function (link) {\n\t\treturn gantt._get_linked_task(link, false);\n\t};\n\n\tvar caching = false;\n\tvar formattedLinksStash = {};\n\tvar inheritedSuccessorsStash = {};\n\tvar inheritedPredecessorsStash = {};\n\tvar getPredecessorsCache = {};\n\n\n\tgantt._isLinksCacheEnabled = function(){\n\t\treturn caching;\n\t};\n\tgantt._startLinksCache = function(){\n\t\tformattedLinksStash = {};\n\t\tinheritedSuccessorsStash = {};\n\t\tinheritedPredecessorsStash = {};\n\t\tgetPredecessorsCache = {};\n\t\tcaching = true;\n\t};\n\tgantt._endLinksCache = function(){\n\t\tformattedLinksStash = {};\n\t\tinheritedSuccessorsStash = {};\n\t\tinheritedPredecessorsStash = {};\n\t\tgetPredecessorsCache = {};\n\t\tcaching = false;\n\t};\n\n\tgantt._formatLink = function (link) {\n\n\n\t\tif(caching && formattedLinksStash[link.id]){\n\t\t\treturn formattedLinksStash[link.id];\n\t\t}\n\n\t\tvar relations = [];\n\t\tvar target = this._get_link_target(link);\n\t\tvar source = this._get_link_source(link);\n\n\t\tif (!(source && target)) {\n\t\t\treturn relations;\n\t\t}\n\n\t\tif ((gantt.isSummaryTask(target) && gantt.isChildOf(source.id, target.id)) || (gantt.isSummaryTask(source) && gantt.isChildOf(target.id, source.id))) {\n\t\t\treturn relations;\n\t\t}\n\n\n\t\t// there are three kinds of connections at this point\n\t\t// task -> task - regular link\n\t\t// task -> project - transform it into set of regular links (task -> [each subtask]), use offset beetween subtask and project dates as lag, in order not to change mutual positions of subtasks inside a project\n\t\t// project -> task - transform it into ([each subtask] -> task) links\n\t\t// project -> project - transform it into ([each subtask of p1] -> [each subtask of p2]) links\n\n\t\tvar from = this._getImplicitLinks(link, source, function (c) {\n\t\t\treturn 0;\n\t\t}, true);\n\n\t\tvar respectTargetOffset = gantt.config.auto_scheduling_move_projects;\n\t\tvar targetDates = this.isSummaryTask(target) ? this.getSubtaskDates(target.id) : {\n\t\t\tstart_date: target.start_date,\n\t\t\tend_date: target.end_date\n\t\t};\n\t\tvar to = this._getImplicitLinks(link, target, function (c) {\n\t\t\tif (!respectTargetOffset) {\n\t\t\t\treturn 0;\n\t\t\t} else {\n\n\t\t\t\tif (!c.$target.length && !(gantt.getState().drag_id == c.id)) {// drag_id - virtual lag shouldn't restrict task that is being moved inside project\n\t\t\t\t\treturn gantt.calculateDuration({\n\t\t\t\t\t\tstart_date: targetDates.start_date,\n\t\t\t\t\t\tend_date: c.start_date,\n\t\t\t\t\t\ttask: source\n\t\t\t\t\t});\n\t\t\t\t} else {\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\n\t\tfor (var i = 0, fromLength = from.length; i < fromLength; i++) {\n\t\t\tvar fromTask = from[i];\n\t\t\tfor (var j = 0, toLength = to.length; j < toLength; j++) {\n\t\t\t\tvar toTask = to[j];\n\n\t\t\t\tvar lag = fromTask.lag * 1 + toTask.lag * 1;\n\n\t\t\t\tvar subtaskLink = {\n\t\t\t\t\tid: link.id,\n\t\t\t\t\ttype: link.type,\n\t\t\t\t\tsource: fromTask.task,\n\t\t\t\t\ttarget: toTask.task,\n\t\t\t\t\tlag: (link.lag * 1 || 0) + lag\n\t\t\t\t};\n\n\t\t\t\trelations.push(gantt._convertToFinishToStartLink(toTask.task, subtaskLink, source, target, fromTask.taskParent, toTask.taskParent));\n\t\t\t}\n\t\t}\n\n\t\tif(caching)\n\t\t\tformattedLinksStash[link.id] = relations;\n\n\t\treturn relations;\n\t};\n\ngantt._isAutoSchedulable = function(task){\n\treturn task.auto_scheduling !== false;\n};\n\ngantt._getImplicitLinks = function(link, parent, selectOffset, selectSourceLinks){\n\tvar relations = [];\n\n\tif(this.isSummaryTask(parent)){\n\n\t\t// if the summary task contains multiple chains of linked tasks - no need to consider every task of the chain,\n\t\t// it will be enough to check the first/last tasks of the chain\n\t\t// special conditions if there are unscheduled tasks in the chain, or negative lag values that put the end date of the successor task prior to its predecessors' date\n\t\tvar children = {};\n\t\tthis.eachTask(function(c){\n\t\t\tif(!this.isSummaryTask(c)){\n\t\t\t\tchildren[c.id] = c;\n\t\t\t}\n\t\t}, parent.id);\n\n\t\tvar skipChild;\n\n\t\tfor(var c in children){\n\t\t\tvar task = children[c];\n\t\t\tvar linksCollection = selectSourceLinks ? task.$source : task.$target;\n\n\t\t\tskipChild = false;\n\n\t\t\tfor(var l = 0; l < linksCollection.length; l++){\n\t\t\t\tvar siblingLink = gantt.getLink(linksCollection[l]);\n\t\t\t\tvar siblingId = selectSourceLinks ? siblingLink.target : siblingLink.source;\n\t\t\t\tvar siblingTask = children[siblingId];\n\t\t\t\tif(siblingTask && task.auto_scheduling !== false && siblingTask.auto_scheduling !== false){\n\t\t\t\t\tif((siblingLink.target == siblingTask.id && Math.abs(siblingLink.lag) <= siblingTask.duration) ||\n\t\t\t\t\t\t(siblingLink.target == task.id && Math.abs(siblingLink.lag) <= task.duration) ){\n\t\t\t\t\t\tskipChild = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(!skipChild){\n\t\t\t\trelations.push({task: task.id, taskParent: task.parent, lag: selectOffset(task)});\n\t\t\t}\n\t\t}\n\n\t}else{\n\t\trelations.push({task:parent.id, taskParent: parent.parent, lag: 0});\n\t}\n\n\t\treturn relations;\n};\n\n\tgantt._getDirectDependencies = function (task, selectSuccessors) {\n\n\t\tvar links = [],\n\t\t\tsuccessors = [];\n\n\t\tvar linksIds = selectSuccessors ? task.$source : task.$target;\n\n\tfor(var i = 0; i < linksIds.length; i++){\n\t\tvar link = this.getLink(linksIds[i]);\n\t\tif(this.isTaskExists(link.source) && this.isTaskExists(link.target)) {\n\t\t\tvar target = this.getTask(link.target);\n\t\t\tif(this._isAutoSchedulable(target)){\n\t\t\t\tlinks.push(this.getLink(linksIds[i]));\n\t\t\t}\n\t\t}\n\t}\n\n\t\tfor (var i = 0; i < links.length; i++) {\n\t\t\tsuccessors = successors.concat(this._formatLink(links[i]));\n\t\t}\n\n\t\treturn successors;\n\t};\n\n\tgantt._getInheritedDependencies = function (task, selectSuccessors) {\n\n\t\t//var successors = [];\n\tvar stop = false;\n\tvar inheritedRelations = [];\n\tvar cacheCollection;\n\tif(this.isTaskExists(task.id)){\n\n\t\tvar parent = this.getParent(task.id);\n\n\n\t\tthis.eachParent(function(parent){\n\t\t\tif(stop)\n\t\t\t\treturn;\n\n\t\t\tif(caching){\n\t\t\t\tcacheCollection = selectSuccessors ? inheritedSuccessorsStash : inheritedPredecessorsStash;\n\t\t\t\tif(cacheCollection[parent.id]){\n\t\t\t\t\tinheritedRelations.push.apply(inheritedRelations, cacheCollection[parent.id]);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tvar parentDependencies;\n\t\t\tif(this.isSummaryTask(parent)){\n\t\t\t\tif(!this._isAutoSchedulable(parent)){\n\t\t\t\t\tstop = true;\n\t\t\t\t}else{\n\t\t\t\t\tparentDependencies = this._getDirectDependencies(parent, selectSuccessors);\n\t\t\t\t\tif(caching){\n\t\t\t\t\t\tcacheCollection[parent.id] = parentDependencies;\n\t\t\t\t\t}\n\t\t\t\t\tinheritedRelations.push.apply(inheritedRelations, parentDependencies);\n\t\t\t\t}\n\t\t\t}\n\n\t\t}, task.id, this);\n\n\t\t//\tfor (var i = 0; i < inheritedRelations.length; i++) {\n\t\t//\t\tsuccessors.push(inheritedRelations[i]);\n\t\t//\t}\n\t\t}\n\n\t\treturn inheritedRelations;\n\t};\n\n\n\tgantt._getDirectSuccessors = function (task) {\n\t\treturn this._getDirectDependencies(task, true);\n\t};\n\n\tgantt._getInheritedSuccessors = function (task) {\n\t\treturn this._getInheritedDependencies(task, true);\n\t};\n\n\tgantt._getDirectPredecessors = function (task) {\n\t\treturn this._getDirectDependencies(task, false);\n\t};\n\n\tgantt._getInheritedPredecessors = function (task) {\n\t\treturn this._getInheritedDependencies(task, false);\n\t};\n\n\tgantt._getSuccessors = function (task, skipInherited) {\n\t\tvar successors = this._getDirectSuccessors(task);\n\t\tif(skipInherited){\n\t\t\treturn successors;\n\t\t}else{\n\t\t\treturn successors.concat(this._getInheritedSuccessors(task));\n\t\t}\n\t};\n\n\tgantt._getPredecessors = function (task, skipInherited) {\n\t\tvar key = task.id + skipInherited;\n\t\tvar result;\n\n\t\tif(caching && getPredecessorsCache[key]){\n\t\t\treturn getPredecessorsCache[key];\n\t\t}\n\n\t\tvar predecessors = this._getDirectPredecessors(task);\n\t\tif(skipInherited){\n\t\t\tresult = predecessors;\n\t\t}else{\n\t\t\tresult = predecessors.concat(this._getInheritedPredecessors(task));\n\t\t}\n\t\tif(caching){\n\t\t\tgetPredecessorsCache[key] = result;\n\t\t}\n\t\treturn result;\n\t};\n\n\n\tgantt._convertToFinishToStartLink = function (id, link, sourceTask, targetTask, sourceParent, targetParent) {\n\t\t// convert finish-to-finish, start-to-finish and start-to-start to finish-to-start link and provide some additional properties\n\t\tvar res = {\n\t\t\ttarget: id,\n\t\t\tlink: gantt.config.links.finish_to_start,\n\t\t\tid: link.id,\n\t\t\tlag: link.lag || 0,\n\t\t\tsource: link.source,\n\t\t\tpreferredStart: null,\n\t\t\tsourceParent: sourceParent,\n\t\t\ttargetParent: targetParent\n\t\t};\n\n\t\tvar additionalLag = 0;\n\t\tswitch (link.type) {\n\t\t\tcase gantt.config.links.start_to_start:\n\t\t\t\tadditionalLag = -sourceTask.duration;\n\t\t\t\tbreak;\n\t\t\tcase gantt.config.links.finish_to_finish:\n\t\t\t\tadditionalLag = -targetTask.duration;\n\t\t\t\tbreak;\n\t\t\tcase gantt.config.links.start_to_finish:\n\t\t\t\tadditionalLag = -sourceTask.duration - targetTask.duration;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tadditionalLag = 0;\n\t\t}\n\n\t\tres.lag += additionalLag;\n\t\treturn res;\n\t};\n};","require(\"../core/links_common\")(gantt);\n\ngantt.config.auto_scheduling = false;\ngantt.config.auto_scheduling_descendant_links = false;\ngantt.config.auto_scheduling_initial = true;\ngantt.config.auto_scheduling_strict = false;\ngantt.config.auto_scheduling_move_projects = true;\n\n(function(){\n\nvar helpers = require(\"../utils/helpers\");\n\n\ngantt._autoSchedulingGraph = {\n\tgetVertices: function(relations){\n\t\tvar ids = {};\n\t\tvar rel;\n\t\tfor(var i = 0, len = relations.length; i < len; i++){\n\t\t\trel = relations[i];\n\t\t\tids[rel.target] = rel.target;\n\t\t\tids[rel.source] = rel.source;\n\t\t}\n\n\t\tvar vertices = [];\n\t\tvar id;\n\t\tfor(var i in ids){\n\t\t\tid = ids[i];\n\t\t\tvertices.push(id);\n\t\t}\n\n\t\treturn vertices;\n\t},\n\ttopologicalSort: function(edges){\n\t\tvar vertices = this.getVertices(edges);\n\t\tvar hash = {};\n\n\t\tfor(var i = 0, len = vertices.length; i < len; i ++){\n\t\t\thash[vertices[i]] = {id: vertices[i], $source:[], $target:[], $incoming: 0};\n\t\t}\n\n\t\tfor(var i = 0, len = edges.length; i < len; i++){\n\t\t\tvar successor = hash[edges[i].target];\n\t\t\tsuccessor.$target.push(i);\n\t\t\tsuccessor.$incoming = successor.$target.length;\n\t\t\thash[edges[i].source].$source.push(i);\n\n\t\t}\n\n\t\t// topological sort, Kahn's algorithm\n\t\tvar S = vertices.filter(function(v){ return !hash[v].$incoming; });\n\n\t\tvar L = [];\n\n\t\twhile(S.length){\n\t\t\tvar n = S.pop();\n\n\t\t\tL.push(n);\n\n\t\t\tvar node = hash[n];\n\n\t\t\tfor(var i = 0; i < node.$source.length; i++){\n\t\t\t\tvar m = hash[edges[node.$source[i]].target];\n\t\t\t\tm.$incoming--;\n\t\t\t\tif(!m.$incoming){\n\t\t\t\t\tS.push(m.id);\n\t\t\t\t}\n\n\t\t\t}\n\t\t}\n\n\t\treturn L;\n\n\t},\n\t_groupEdgesBySource: function(edges){\n\t\tvar res = {};\n\t\tvar edge;\n\t\tfor(var i = 0, len = edges.length; i < len; i++){\n\t\t\tedge = edges[i];\n\t\t\tif(!res[edge.source]){\n\t\t\t\tres[edge.source] = [];\n\t\t\t}\n\t\t\tres[edge.source].push(edge);\n\t\t}\n\t\treturn res;\n\t},\n\ttarjanStronglyConnectedComponents: function(vertices, edges){\n\t\t//https://en.wikipedia.org/wiki/Tarjan%27s_strongly_connected_components_algorithm\n\t\tvar verticesHash = {};\n\n\t\tvar index = 0;\n\t\tvar S = [];\n\t\tvar connectedEdges = [];\n\t\tvar connectedComponents = [];\n\n\t\tvar edgesFromTasks = this._groupEdgesBySource(edges);\n\n\t\tvar vertexId;\n\t\tfor(var v = 0, len = vertices.length; v < len; v++){\n\t\t\tvertexId = vertices[v];\n\t\t\tvar vertex = getVertex(vertexId);\n\t\t\tif(vertex.index === undefined){\n\t\t\t\tstrongConnect(vertexId);\n\t\t\t}\n\t\t}\n\n\t\tfunction strongConnect(vertexId, previousLink){\n\t\t\tvar v = getVertex(vertexId);\n\t\t\tv.index = index;\n\t\t\tv.lowLink = index;\n\t\t\tindex++;\n\n\t\t\tif(previousLink){\n\t\t\t\tconnectedEdges.push(previousLink);\n\t\t\t}\n\n\t\t\tS.push(v);\n\t\t\tv.onStack = true;\n\n\t\t\t// Consider successors of v\n\n\t\t\tvar edge;\n\t\t\tvar successors = edgesFromTasks[vertexId];\n\t\t\tfor(var e = 0; successors  && e < successors.length; e++){\n\t\t\t\tedge = successors[e];\n\t\t\t\tif(edge.source != vertexId) continue;\n\n\t\t\t\tvar v = getVertex(edge.source);\n\t\t\t\tvar w = getVertex(edge.target);\n\t\t\t\tif(w.index === undefined){\n\t\t\t\t\t// Successor w has not yet been visited; recurse on it\n\t\t\t\t\tstrongConnect(edge.target, edge);\n\t\t\t\t\tv.lowLink = Math.min(v.lowLink, w.lowLink);\n\t\t\t\t}else if(w.onStack){\n\t\t\t\t\t// Successor w is in stack S and hence in the current SCC\n\t\t\t\t\tv.lowLink = Math.min(v.lowLink, w.index);\n\t\t\t\t\tconnectedEdges.push(edge);\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// If v is a root node, pop the stack and generate an SCC\n\t\t\tif(v.lowLink == v.index){\n\t\t\t\tvar connectedComponent = {tasks: [], links:[]};\n\t\t\t\tvar w;\n\t\t\t\tdo{\n\t\t\t\t\tvar rel = connectedEdges.pop();\n\t\t\t\t\tw = S.pop();\n\t\t\t\t\tw.onStack = false;\n\t\t\t\t\tconnectedComponent.tasks.push(w.id);\n\t\t\t\t\tif(rel){\n\t\t\t\t\t\tconnectedComponent.links.push(rel.id);\n\t\t\t\t\t}\n\t\t\t\t}while(w.id != v.id);\n\t\t\t\tconnectedComponents.push(connectedComponent);\n\t\t\t}\n\n\t\t}\n\n\t\treturn connectedComponents;\n\n\t\tfunction getVertex(id){\n\t\t\tif(!verticesHash[id]){\n\t\t\t\tverticesHash[id] = {id: id, onStack:false, index: undefined, lowLink: undefined};\n\t\t\t}\n\n\t\t\treturn verticesHash[id];\n\t\t}\n\n\t}\n\n};\n\ngantt._autoSchedulingPath = {\n\tgetKey: function(rel){\n\t\treturn rel.lag +\"_\"+ rel.link +\"_\"+ rel.source +\"_\"+ rel.target;\n\t},\n\tgetVirtualRoot: function(){\n\t\treturn gantt.mixin(\n\t\t\tgantt.getSubtaskDates(),\n\t\t\t{\n\t\t\t\tid: gantt.config.root_id,\n\t\t\t\ttype: gantt.config.types.project,\n\t\t\t\t$source: [],\n\t\t\t\t$target: [],\n\t\t\t\t$virtual: true\n\t\t\t}\n\t\t);\n\t},\n\n\tfilterDuplicates: function(relations){\n\t\tvar keys = {};\n\t\tfor(var i = 0; i < relations.length; i++){\n\t\t\tvar key = this.getKey(relations[i]);\n\t\t\tif(keys[key]){\n\t\t\t\trelations.splice(i, 1);\n\t\t\t\ti--;\n\t\t\t}else{\n\t\t\t\tkeys[key] = true;\n\t\t\t}\n\t\t}\n\t\treturn relations;\n\t},\n\n\tgetLinkedTasks: function(id, includePredecessors){\n\t\tvar startIds = [id];\n\n\t\t//TODO: format links cache\n\t\tvar clearCache = false;\n\t\tif(!gantt._isLinksCacheEnabled()) {\n\t\t\tgantt._startLinksCache();\n\t\t\tclearCache = true;\n\t\t}\n\t\tvar relations = [];\n\t\tvar visited = {};\n\t\tfor(var i = 0; i < startIds.length; i++){\n\t\t\tthis._getLinkedTasks(startIds[i], visited, includePredecessors);\n\t\t}\n\n\t\tfor(var i in visited){\n\t\t\trelations.push(visited[i]);\n\t\t}\n\t\tif(clearCache)\n\t\t\tgantt._endLinksCache();\n\t\treturn relations;\n\t},\n\n\t_getLinkedTasks: function(rootTask, visitedTasks, includePredecessors, isChild) {\n\t\tvar from = rootTask === undefined ? gantt.config.root_id : rootTask;\n\t\tvar visited = visitedTasks || {};\n\n\t\tvar rootObj = gantt.isTaskExists(from) ? gantt.getTask(from) : this.getVirtualRoot();\n\n\t\tvar successors = gantt._getSuccessors(rootObj, isChild);\n\n\t\tvar predecessors = [];\n\t\tif (includePredecessors) {\n\t\t\tpredecessors = gantt._getPredecessors(rootObj, isChild);\n\t\t}\n\t\tvar relations = [];\n\t\tvar linkKey;\n\n\t\tfor(var i = 0; i < successors.length; i++){\n\t\t\tlinkKey = this.getKey(successors[i]);\n\t\t\tif(visited[linkKey]) {\n\t\t\t\tcontinue;\n\t\t\t}else{\n\t\t\t\tvisited[linkKey] = successors[i];\n\t\t\t\trelations.push(successors[i]);\n\t\t\t}\n\t\t}\n\t\tfor(var i = 0; i < predecessors.length; i++){\n\t\t\tlinkKey = this.getKey(predecessors[i]);\n\t\t\tif(visited[linkKey]) {\n\t\t\t\tcontinue;\n\t\t\t}else{\n\t\t\t\tvisited[linkKey] = predecessors[i];\n\t\t\t\trelations.push(predecessors[i]);\n\t\t\t}\n\t\t}\n\n\t\tfor(var i=0; i < relations.length; i++){\n\t\t\tvar isSameParent = relations[i].sourceParent == relations[i].targetParent;\n\t\t\tthis._getLinkedTasks(relations[i].target, visited, true, isSameParent);\n\t\t}\n\n\t\tif(gantt.hasChild(rootObj.id)){\n\t\t\tvar children = gantt.getChildren(rootObj.id);\n\t\t\tfor(var i=0; i < children.length; i++){\n\t\t\t\tthis._getLinkedTasks(children[i], visited, true, true);\n\t\t\t}\n\t\t}\n\n\t\treturn relations;\n\t},\n\n\tfindLoops: function(relations){\n\n\t\tvar cycles = [];\n\n\t\thelpers.forEach(relations, function(rel){\n\t\t\tif(rel.target == rel.source)\n\t\t\t\tcycles.push([rel.target, rel.source]);\n\t\t});\n\n\t\tvar graph =  gantt._autoSchedulingGraph;\n\t\tvar vertices = graph.getVertices(relations);\n\n\t\tvar connectedComponents = graph.tarjanStronglyConnectedComponents(vertices, relations);\n\n\t\thelpers.forEach(connectedComponents, function(component){\n\t\t\tif(component.tasks.length > 1){\n\t\t\t\tcycles.push(component);//{ tasks: [task ids], links: [links ids]}\n\t\t\t}\n\t\t});\n\n\t\treturn cycles;\n\t\t//{task:id, link:link.type, lag: link.lag || 0, source: link.source}\n\t}\n};\n\ngantt._autoSchedulingDateResolver = {\n\tisFirstSmaller: function(small, big, task){\n\t\tif(small.valueOf() < big.valueOf() && gantt._hasDuration(small, big, task))\n\t\t\treturn true;\n\t\treturn false;\n\t},\n\n\tisSmallerOrDefault: function(smallDate, bigDate, task){\n\t\treturn !!(!smallDate || this.isFirstSmaller(smallDate, bigDate, task));\n\t},\n\n\tresolveRelationDate: function(taskId, relations, getEndDate){\n\t\tvar minStart = null;\n\t\tvar linkId = null;\n\n\t\tvar defaultStart = null;\n\t\tvar task;\n\t\tfor(var i = 0; i < relations.length; i++){\n\t\t\tvar relation = relations[i];\n\t\t\ttaskId = relation.target;\n\n\t\t\tdefaultStart = relation.preferredStart;\n\t\t\ttask = gantt.getTask(taskId);\n\t\t\tvar constraintDate = this.getConstraintDate(relation, getEndDate, task);\n\n\n\t\t\tif(this.isSmallerOrDefault(defaultStart, constraintDate, task) && this.isSmallerOrDefault(minStart, constraintDate, task)){\n\t\t\t\tminStart = constraintDate;\n\t\t\t\tlinkId = relation.id;\n\t\t\t}\n\n\t\t}\n\n\t\tif(minStart){\n\t\t\tminStart = gantt.getClosestWorkTime({date:minStart, dir:\"future\", task:gantt.getTask(taskId)});\n\t\t}\n\n\t\treturn {\n\t\t\tlink: linkId,\n\t\t\ttask: taskId,\n\t\t\tstart_date: minStart\n\t\t};\n\t},\n\tgetConstraintDate: function(relation, getEndDate, task){\n\t\tvar predecessorEnd = getEndDate(relation.source);\n\t\tvar successor = task;\n\n\t\tvar successorStart = gantt.getClosestWorkTime({date:predecessorEnd, dir:\"future\", task:successor});\n\n\t\tif(predecessorEnd && relation.lag && relation.lag*1 == relation.lag){\n\t\t\tsuccessorStart = gantt.calculateEndDate({start_date: predecessorEnd, duration: relation.lag*1, task: successor});\n\t\t}\n\n\t\treturn successorStart;\n\t}\n};\n\ngantt._autoSchedulingPlanner = {\n\tgeneratePlan: function(relations){\n\n\t\tvar graph = gantt._autoSchedulingGraph;\n\t\tvar orderedIds = graph.topologicalSort(relations);\n\t\tvar predecessorRelations = {},\n\t\t\tplansHash = {};\n\n\t\tvar id;\n\t\tfor(var i = 0, len = orderedIds.length; i < len; i++){\n\t\t\tid = orderedIds[i];\n\t\t\tvar task = gantt.getTask(id);\n\t\t\tif(task.auto_scheduling === false){\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tpredecessorRelations[id] = [];\n\t\t\tplansHash[id] = null;\n\t\t}\n\n\t\tfunction getPredecessorEndDate(id){\n\t\t\tvar plan = plansHash[id];\n\t\t\tvar task = gantt.getTask(id);\n\t\t\tvar res;\n\n\t\t\tif(!(plan && (plan.start_date || plan.end_date))){\n\t\t\t\tres = task.end_date;\n\t\t\t}else if(plan.end_date){\n\t\t\t\tres = plan.end_date;\n\t\t\t}else {\n\t\t\t\tres = gantt.calculateEndDate({start_date: plan.start_date, duration: task.duration, task: task});\n\t\t\t}\n\n\t\t\treturn res;\n\t\t}\n\n\t\tvar rel;\n\t\tfor(var i = 0, len = relations.length; i < len; i++){\n\t\t\trel = relations[i];\n\t\t\tif(predecessorRelations[rel.target]) {\n\t\t\t\tpredecessorRelations[rel.target].push(rel);\n\t\t\t}\n\t\t}\n\n\t\tvar dateResolver = gantt._autoSchedulingDateResolver;\n\n\t\tvar result = [];\n\t\tfor(var i = 0; i < orderedIds.length; i++){\n\t\t\tvar currentId = orderedIds[i];\n\n\t\t\tvar plan = dateResolver.resolveRelationDate(currentId, predecessorRelations[currentId] || [], getPredecessorEndDate);\n\n\n\t\t\tif(plan.start_date && gantt.isLinkExists(plan.link)){\n\t\t\t\tvar link = gantt.getLink(plan.link);\n\t\t\t\tvar task = gantt.getTask(currentId);\n\t\t\t\tvar predecessor = gantt.getTask(link.source);\n\n\t\t\t\tif (task.start_date.valueOf() !== plan.start_date.valueOf() && gantt.callEvent(\"onBeforeTaskAutoSchedule\", [task, plan.start_date, link, predecessor]) === false) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tplansHash[currentId] = plan;\n\t\t\tif(plan.start_date){\n\t\t\t\tresult.push(plan);\n\t\t\t}\n\t\t}\n\n\t\treturn result;\n\n\t},\n\n\tapplyProjectPlan: function(projectPlan){\n\t\tvar plan, task, link, predecessor;\n\n\t\tvar updateTasks = [];\n\t\tfor(var i = 0; i <  projectPlan.length; i++){\n\t\t\tlink = null;\n\t\t\tpredecessor = null;\n\t\t\tplan = projectPlan[i];\n\n\t\t\tif(!plan.task) continue;\n\n\t\t\ttask = gantt.getTask(plan.task);\n\t\t\tif(plan.link){\n\t\t\t\tlink = gantt.getLink(plan.link);\n\t\t\t\tpredecessor = gantt.getTask(link.source);\n\t\t\t}\n\n\t\t\tvar newDate = null;\n\t\t\tif(plan.start_date && (task.start_date.valueOf() != plan.start_date.valueOf())){\n\t\t\t\tnewDate = plan.start_date;\n\t\t\t}\n\n\t\t\tif(!newDate) continue;\n\t\t\t\n\t\t\ttask.start_date = newDate;\n\t\t\ttask.end_date = gantt.calculateEndDate(task);\n\n\t\t\tupdateTasks.push(task.id);\n\t\t\tgantt.callEvent(\"onAfterTaskAutoSchedule\", [task, newDate, link, predecessor]);\n\n\t\t}\n\t\treturn updateTasks;\n\t}\n};\n\ngantt._autoSchedulingPreferredDates = function(startTask, relations){\n\tfor(var i = 0; i < relations.length; i++){\n\t\tvar rel = relations[i];\n\t\tvar task = gantt.getTask(rel.target);\n\n\t\tif(!gantt.config.auto_scheduling_strict || rel.target == startTask){\n\t\t\trel.preferredStart = new Date(task.start_date);\n\t\t}\n\t}\n};\n\ngantt._autoSchedule = function(id, relations, updateCallback){\n\tif (gantt.callEvent(\"onBeforeAutoSchedule\", [id]) === false) {\n\t\treturn;\n\t}\n\tgantt._autoscheduling_in_progress = true;\n\n\tvar path = gantt._autoSchedulingPath;\n\n\tvar updatedTasks = [];\n\n\tvar cycles = path.findLoops(relations);\n\tif(cycles.length){\n\t\tgantt.callEvent(\"onAutoScheduleCircularLink\", [cycles]);\n\t}else{\n\n\t\tvar planner = gantt._autoSchedulingPlanner;\n\t\tgantt._autoSchedulingPreferredDates(id, relations);\n\n\t\tvar plan = planner.generatePlan(relations);\n\t\tupdatedTasks = planner.applyProjectPlan(plan);\n\n\t\tif(updateCallback){\n\t\t\tupdateCallback(updatedTasks);\n\t\t}\n\t}\n\n\tgantt._autoscheduling_in_progress = false;\n\tgantt.callEvent(\"onAfterAutoSchedule\", [id, updatedTasks]);\n\n\treturn updatedTasks;\n};\n\ngantt.autoSchedule = function(id, inclusive){\n\n\tif(inclusive === undefined){\n\t\tinclusive = true;\n\t}else{\n\t\tinclusive = !!inclusive;\n\t}\n\n\tvar relations =  gantt._autoSchedulingPath.getLinkedTasks(id, inclusive);\n\n\tvar totalRelations = relations.length;\n\tvar startAutoSchedule = Date.now();\n\tgantt._autoSchedule(id, relations, gantt._finalizeAutoSchedulingChanges);\n\tvar durationAutoSchedule = Date.now() - startAutoSchedule;\n};\n\ngantt._finalizeAutoSchedulingChanges = function(updatedTasks){\n\tfunction resetTime(task){\n\t\tif(batchUpdate)\n\t\t\treturn;\n\n\t\tvar start = task.start_date.valueOf(),\n\t\t\tend = task.end_date.valueOf();\n\n\t\tgantt.resetProjectDates(task);\n\t\tif(task.start_date.valueOf() != start || task.end_date.valueOf() != end){\n\t\t\tbatchUpdate = true;\n\t\t\treturn;\n\t\t}\n\t\tvar children = gantt.getChildren(task.id);\n\t\tfor(var i = 0; !batchUpdate && i < children.length; i++){\n\t\t\tresetTime(gantt.getTask(children[i]));\n\t\t}\n\t}\n\n\tvar batchUpdate = false;\n\t// call batchUpdate (full repaint) only if we update multiple tasks,\n\tif(updatedTasks.length == 1){\n\t\tgantt.eachParent(resetTime, updatedTasks[0]);\n\t}else if(updatedTasks.length){\n\t\tbatchUpdate = true;\n\t}\n\n\tfunction payload(){\n\t\tfor(var i = 0; i < updatedTasks.length; i++){\n\t\t\tgantt.updateTask(updatedTasks[i]);\n\t\t}\n\t}\n\tif(batchUpdate){\n\t\tgantt.batchUpdate(payload);\n\t}else{\n\t\tpayload();\n\t}\n\n};\n\ngantt.isCircularLink = function(link){\n\treturn !!gantt._getConnectedGroup(link);\n\n};\n\ngantt._getConnectedGroup = function(link){\n\tvar manager = gantt._autoSchedulingPath;\n\n\tvar allRelations = manager.getLinkedTasks();\n\tif(!gantt.isLinkExists(link.id)){\n\t\tallRelations = allRelations.concat(gantt._formatLink(link));\n\t}\n\n\tvar cycles = manager.findLoops(allRelations);\n\n\tvar found = false;\n\tfor(var i = 0; (i < cycles.length) && !found; i++){\n\t\tvar links = cycles[i].links;\n\t\tfor(var j = 0; j < links.length; j++){\n\t\t\tif(links[j] == link.id){\n\t\t\t\treturn cycles[i];\n\t\t\t}\n\t\t}\n\t}\n\n\treturn null;\n};\n\ngantt.findCycles = function(){\n\tvar manager = gantt._autoSchedulingPath;\n\n\tvar allRelations = manager.getLinkedTasks();\n\treturn manager.findLoops(allRelations);\n};\n\ngantt._attachAutoSchedulingHandlers = function(){\n\n\tgantt._autoScheduleAfterLinkChange = function (linkId, link) {\n\t\tif (gantt.config.auto_scheduling && !this._autoscheduling_in_progress) {\n\t\t\tgantt.autoSchedule(link.source);\n\t\t}\n\t};\n\n\tgantt.attachEvent(\"onAfterLinkUpdate\", gantt._autoScheduleAfterLinkChange);\n\tgantt.attachEvent(\"onAfterLinkAdd\", gantt._autoScheduleAfterLinkChange);\n\n\tgantt.attachEvent(\"onAfterLinkDelete\", function(id, link){\n\t\tif (this.config.auto_scheduling && !this._autoscheduling_in_progress && this.isTaskExists(link.target)) {\n\t\t\t// after link deleted - auto schedule target for other relations that may be left\n\t\t\tvar target = this.getTask(link.target);\n\t\t\tvar predecessors = this._getPredecessors(target);\n\t\t\tif(predecessors.length){\n\t\t\t\tthis.autoSchedule(predecessors[0].source, false);\n\t\t\t}\n\t\t}\n\t});\n\n\tgantt.attachEvent(\"onParse\", function(){\n\t\tif (gantt.config.auto_scheduling && gantt.config.auto_scheduling_initial) {\n\t\t\tgantt.autoSchedule();\n\t\t}\n\t});\n\n\tgantt._preventCircularLink = function(id, link){\n\t\tif(gantt.isCircularLink(link)){\n\t\t\tgantt.callEvent(\"onCircularLinkError\", [link, gantt._getConnectedGroup(link)]);\n\t\t\treturn false;\n\t\t}else{\n\t\t\treturn true;\n\t\t}\n\t};\n\n\tgantt._preventDescendantLink = function(id, link){\n\t\tvar source = gantt.getTask(link.source),\n\t\t\ttarget = gantt.getTask(link.target);\n\n\t\tif(!gantt.config.auto_scheduling_descendant_links){\n\t\t\tif((gantt.isChildOf(source.id, target.id) && gantt.isSummaryTask(target)) || (gantt.isChildOf(target.id, source.id) && gantt.isSummaryTask(source))){\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t};\n\n\tgantt.attachEvent(\"onBeforeLinkAdd\", gantt._preventCircularLink);\n\tgantt.attachEvent(\"onBeforeLinkAdd\", gantt._preventDescendantLink);\n\tgantt.attachEvent(\"onBeforeLinkUpdate\", gantt._preventCircularLink);\n\tgantt.attachEvent(\"onBeforeLinkUpdate\", gantt._preventDescendantLink);\n\n\tgantt._datesNotEqual = function(dateA, dateB, taskA, taskB){\n\t\tif(dateA.valueOf() > dateB.valueOf()){\n\t\t\treturn this._hasDuration({start_date: dateB, end_date: dateA, task: taskB});\n\t\t}else{\n\t\t\treturn this._hasDuration({start_date: dateA, end_date: dateB, task: taskA});\n\t\t}\n\t};\n\tgantt._notEqualTaskDates = function(task1, task2){\n\t\tif (this._datesNotEqual(task1.start_date, task2.start_date, task1, task2) ||\n\t\t\t((this._datesNotEqual(task1.end_date, task2.end_date, task1, task2) ||\n\t\t\t\ttask1.duration != task2.duration) && task1.type != gantt.config.types.milestone)) {\n\t\t\treturn true;\n\t\t}\n\t};\n\n\tvar relations;\n\tvar movedTask;\n\tgantt.attachEvent(\"onBeforeTaskDrag\", function(id, mode, task){\n\t\tif(gantt.config.auto_scheduling && gantt.config.auto_scheduling_move_projects){\n\t\t\t// collect relations before drag and drop  in order to have original positions of subtasks within project since they are used as lag when moving dependent project\n\t\t\trelations = gantt._autoSchedulingPath.getLinkedTasks(id, true);\n\t\t\tmovedTask = id;\n\t\t}\n\t\treturn true;\n\t});\n\n\tfunction resetToStartLinksLags(taskId, relations){\n\t\tvar skipped = false;\n\t\tfor(var i = 0; i < relations.length; i++){\n\t\t\tvar originalLink = gantt.getLink(relations[i].id);\n\t\t\tif(originalLink.type == gantt.config.links.start_to_start || originalLink.type == gantt.config.links.start_to_finish){\n\t\t\t\trelations.splice(i, 1);\n\t\t\t\ti--;\n\t\t\t\tskipped = true;\n\t\t\t}\n\t\t}\n\n\t\tif(skipped){\n\t\t\tvar presentLinks = {};\n\t\t\tfor(var i = 0; i < relations.length; i++){\n\t\t\t\tpresentLinks[relations[i].id] = true;\n\t\t\t}\n\n\t\t\tvar updatedLinks = gantt._autoSchedulingPath.getLinkedTasks(taskId, true);\n\t\t\tfor(var i = 0; i < updatedLinks.length; i++){\n\t\t\t\tif(!presentLinks[updatedLinks[i].id]){\n\t\t\t\t\trelations.push(updatedLinks[i]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tgantt._autoScheduleAfterDND = function(taskId, task){\n\t\tif (gantt.config.auto_scheduling && !this._autoscheduling_in_progress) {\n\t\t\tvar newTask = this.getTask(taskId);\n\t\t\tif (gantt._notEqualTaskDates(task, newTask)){\n\t\t\t\tif(gantt.config.auto_scheduling_move_projects && movedTask == taskId){\n\n\t\t\t\t\tif(gantt.calculateDuration(task) != gantt.calculateDuration(newTask)){\n\t\t\t\t\t\t// task duration is used as lag when converting start_to_start and start_to_finish into finish to start links\n\t\t\t\t\t\t// recalculate these links if task duration has changed\n\t\t\t\t\t\tresetToStartLinksLags(taskId, relations);\n\t\t\t\t\t}\n\n\n\t\t\t\t\tgantt._autoSchedule(taskId, relations, gantt._finalizeAutoSchedulingChanges);\n\t\t\t\t}else{\n\t\t\t\t\tgantt.autoSchedule(newTask.id);\n\t\t\t\t}\n\n\n\t\t\t}\n\t\t}\n\t\trelations = null;\n\t\tmovedTask = null;\n\t\treturn true;\n\t};\n\n\tgantt._lightBoxChangesHandler = function (taskId, task) {\n\t\tif (gantt.config.auto_scheduling && !this._autoscheduling_in_progress) {\n\t\t\tvar oldTask = this.getTask(taskId);\n\t\t\tif (gantt._notEqualTaskDates(task, oldTask)) {\n\t\t\t\tgantt._autoschedule_lightbox_id = taskId;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t};\n\tgantt._lightBoxSaveHandler = function (taskId, task) {\n\n\t\tif (gantt.config.auto_scheduling && !this._autoscheduling_in_progress) {\n\t\t\tif (gantt._autoschedule_lightbox_id && gantt._autoschedule_lightbox_id == taskId) {\n\t\t\t\tgantt._autoschedule_lightbox_id = null;\n\t\t\t\tgantt.autoSchedule(task.id);\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t};\n\n\tgantt.attachEvent(\"onBeforeTaskChanged\", function(id, mode, task){ return gantt._autoScheduleAfterDND(id, task); });\n\tgantt.attachEvent(\"onLightboxSave\", gantt._lightBoxChangesHandler);\n\tgantt.attachEvent(\"onAfterTaskUpdate\", gantt._lightBoxSaveHandler);\n\n};\n\ngantt.attachEvent(\"onGanttReady\", function(){\n\tgantt._attachAutoSchedulingHandlers();\n\t// attach handlers only when initialized for the first time\n\tgantt._attachAutoSchedulingHandlers = function(){};\n});\n\ngantt.getConnectedGroup = function(id){\n\tvar links = gantt._autoSchedulingPath.getLinkedTasks();\n\tif(id !== undefined){\n\t\tif(gantt.getTask(id).type == gantt.config.types.project){\n\t\t\treturn {tasks: [], links: []};\n\t\t}\n\t\treturn breadthFirstSearch(id, links, {});\n\t}else{\n\t\treturn findGroups(links);\n\t}\n};\n\nfunction findGroups(links){\n\tvar visited = {};\n\tvar groups = [];\n\tvar source, target, root;\n\t// main loop - find any unvisited vertex from the input array and\n\t// treat it as the source, then perform a breadth first search from\n\t// it. All vertices visited from this search belong to the same group\n\tfor (var i = 0; i < links.length; i++) {\n\t\tsource = links[i].source;\n\t\ttarget = links[i].target;\n\t\troot = null;\n\t\tif (!visited[source]) {\n\t\t\troot = source;\n\t\t} else if (!visited[target]) {\n\t\t\troot = target;\n\t\t}\n\t\tif (root) {\n\t\t\t// there is an unvisited vertex in this pair.\n\t\t\t// perform a breadth first search, and push the resulting\n\t\t\t// group onto the list of all groups\n\t\t\tgroups.push(breadthFirstSearch(root, links, visited));\n\t\t}\n\t}\n\treturn groups;\n}\n\n// Breadth First Search function\n// v is the source vertex\n// links is the input array, which contains all gantt relations\n// visited is a dictionary for keeping track of whether a node is visited\nfunction breadthFirstSearch(v, links, visited) {\n\tvar queue = [v];\n\tvar groupTasks = [],\n\t\tgroupLinks = {};\n\n\tvar currentVertex;\n\twhile (queue.length > 0) {\n\t\tcurrentVertex = queue.shift();\n\t\tif (!visited[currentVertex]) {\n\t\t\tvisited[currentVertex] = true;\n\t\t\tgroupTasks.push(currentVertex);\n\t\t\t// go through the input array to find vertices that are\n\t\t\t// directly adjacent to the current vertex, and put them\n\t\t\t// onto the queue\n\t\t\tfor (var i = 0; i < links.length; i++) {\n\t\t\t\tvar link = links[i];\n\t\t\t\tif (link.source == currentVertex && !visited[link.target]) {\n\t\t\t\t\tqueue.push(link.target);\n\t\t\t\t\tgroupLinks[link.id] = true;\n\t\t\t\t\tlinks.splice(i, 1);\n\t\t\t\t\ti--;\n\t\t\t\t} else if (link.target == currentVertex && !visited[link.source]) {\n\t\t\t\t\tqueue.push(link.source);\n\t\t\t\t\tgroupLinks[link.id] = true;\n\t\t\t\t\tlinks.splice(i, 1);\n\t\t\t\t\ti--;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tvar linksArray = [];\n\tfor(var i in groupLinks){\n\t\tlinksArray.push(i);\n\t}\n\t// return everything in the current \"group\"\n\treturn {tasks: groupTasks, links: linksArray};\n}\n\n\n})();","var units = {\n\t\"second\": 1,\n\t\"minute\": 60,\n\t\"hour\": 60 * 60,\n\t\"day\": 60 * 60 * 24,\n\t\"week\": 60 * 60 * 24 * 7,\n\t\"month\": 60 * 60 * 24 * 30,\n\t\"quarter\": 60 * 60 * 24 * 30 * 3,\n\t\"year\": 60 * 60 * 24 * 365\n};\nfunction getSecondsInUnit(unit){\n\treturn units[unit] || units.hour;\n}\n\nfunction forEach(arr, callback){\n\tif(arr.forEach){\n\t\tarr.forEach(callback);\n\t}else{\n\t\tvar workArray = arr.slice();\n\t\tfor(var i = 0; i < workArray.length; i++){\n\t\t\tcallback(workArray[i], i);\n\t\t}\n\t}\n}\n\nfunction arrayMap(arr, callback){\n\tif(arr.map){\n\t\treturn arr.map(callback);\n\t}else{\n\t\tvar workArray = arr.slice();\n\t\tvar resArray = [];\n\n\t\tfor(var i = 0; i < workArray.length; i++){\n\t\t\tresArray.push(callback(workArray[i], i));\n\t\t}\n\n\t\treturn resArray;\n\t}\n\n}\n\nmodule.exports = {\n\tgetSecondsInUnit: getSecondsInUnit,\n\tforEach: forEach,\n\tarrayMap: arrayMap\n};"],"sourceRoot":""}